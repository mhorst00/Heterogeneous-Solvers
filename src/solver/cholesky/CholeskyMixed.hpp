#ifndef CHOLESKYMIXED_HPP
#define CHOLESKYMIXED_HPP

#include <sycl/sycl.hpp>

#include "LoadBalancer.hpp"
#include "MetricsTracker.hpp"
#include "SymmetricMatrixMixed.hpp"

using namespace sycl;

/**
 * This class contains the heterogeneous implementation of the Cholesky
 * decomposition.
 */
class CholeskyMixed {
public:
  CholeskyMixed(SymmetricMatrixMixed &A, queue &cpuQueue, queue &gpuQueue,
                std::shared_ptr<LoadBalancer> loadBalancer);
  ~CholeskyMixed();

  SymmetricMatrixMixed &A; /// Mixed precision SPD matrix A
  unsigned char *A_gpu;    /// GPU data structure for A

  queue &cpuQueue; /// SYCL queue for the CPU device
  queue &gpuQueue; /// SYCL queue for the GPU device

  std::shared_ptr<LoadBalancer> loadBalancer; /// load balancer to dynamically or statically
                                              /// determine the CPU/GPU split
  MetricsTracker metricsTracker; /// metrics tracker that tracks various runtime metrics

  double gpuProportion; /// current GPU proportion

  void solve_heterogeneous(); /// main method that starts the heterogeneous
                              /// Cholesky decomposition

  void writeMetricsToFile(); /// writes the json file generated by the metrics
                             /// tracker with all runtime metrics

private:
  /// struct that stores various execution times of the steps of the algorithm
  struct executionTimes {
    std::chrono::time_point<std::chrono::steady_clock> start;
    std::chrono::time_point<std::chrono::steady_clock> end;

    std::chrono::time_point<std::chrono::steady_clock> startMemoryInitGPU;
    std::chrono::time_point<std::chrono::steady_clock> endMemoryInitGPU;

    std::chrono::time_point<std::chrono::steady_clock> startColumn;

    std::chrono::time_point<std::chrono::steady_clock> startCholesky;
    std::chrono::time_point<std::chrono::steady_clock> endCholesky;

    std::chrono::time_point<std::chrono::steady_clock> startCopy_row;
    std::chrono::time_point<std::chrono::steady_clock> endCopy_row;

    std::chrono::time_point<std::chrono::steady_clock> startCopy_column;
    std::chrono::time_point<std::chrono::steady_clock> endCopy_column;

    std::chrono::time_point<std::chrono::steady_clock> startTriangularSolve;
    std::chrono::time_point<std::chrono::steady_clock> endTriangularSolve;

    std::chrono::time_point<std::chrono::steady_clock> startMatrixMatrixDiagonal;
    std::chrono::time_point<std::chrono::steady_clock> endMatrixMatrixDiagonal;

    std::chrono::time_point<std::chrono::steady_clock> startMatrixMatrix;
    std::chrono::time_point<std::chrono::steady_clock> endMatrixMatrix;

    std::chrono::time_point<std::chrono::steady_clock> startResultCopyGPU;
    std::chrono::time_point<std::chrono::steady_clock> endResultCopyGPU;

    sycl::event eventCPU_matrixMatrix;
    sycl::event eventGPU_matrixMatrix;

    sycl::event eventCPU_matrixMatrixDiag;
    sycl::event eventGPU_matrixMatrixDiag;

    sycl::event eventCPU_triangularSolve;
    sycl::event eventGPU_triangularSolve;
  } executionTimes;

  // variables
  int blockCountGPU;
  int blockCountCPU;
  int blockStartGPU;
  int offsetMatrixMatrixStepGPU = 0;
  int minBlockCountGPU;

  /**
   * Operation that waits on the CPU and GPU queue
   */
  void waitAllQueues();

  /**
   * Operation that initializes the GPU memory
   */
  void initGPUMemory();

  /**
   * Operation that initializes the execution times struct
   */
  void initExecutionTimes();

  /**
   * This operation shifts the horizontal split between the CPU and GPU up or
   * down depending on the new desired GPU proportion. It ensures consistency of
   * the matrix across the CPU and GPU after split is shifted.
   */
  void shiftSplit(int blockCountATotal, std::size_t blockSizeBytes, int k,
                  std::size_t blockOffsetDiagBlock);

  /**
   * Performs the first step of a column step of the Cholesky decomposition: a
   * small Cholesky decomposition of the current diagonal block.
   *
   * @param blockSizeBytes size of one block in bytes
   * @param k column k
   * @param blockID id of the diagonal block
   * @param blockStartIndexDiagBlock start index of the diagonal block in the
   * data structure
   */
  void choleskyUpdateCurrentDiagonalBlock(std::size_t blockSizeBytes, int blockPrecision, int k,
                                          std::size_t blockOffsetDiagBlock);

  /**
   * Performs the second step of a column step of the Cholesky decomposition:
   * updating the column below the diagonal block by solving a matrix equation.
   *
   * @param blockSizeBytes size of one block in bytes
   * @param k column k
   * @param blockID id of the diagonal block
   */
  void choleskySolveTriangularSystemColumn(int k, int blockID);

  /**
   * Performs the third step of a column step of the Cholesky decomposition:
   * updating the remaining diagonal blocks using symmetric matrix-matrix
   * multiplications
   *
   * @param k column k
   * @param blockID id of the diagonal block
   */
  void choleskyUpdateDiagonal(int k, int blockID);

  /**
   * Performs the third step of a column step of the Cholesky decomposition:
   * updating the remaining non-diagonal blocks using matrix-matrix
   * multiplications.
   *
   * @param k
   * @param blockID
   */
  void choleskyUpdateLowerBlockTriangle(int k, int blockID);

  /**
   * Prints the runtimes of the individual steps for the current column
   * processing step
   *
   * @param k column k
   */
  void printTimes(int k);

  /**
   * This operation copies the part of the final lower triangular matrix
   * computed on the GPU to the CPU after the decomposition
   *
   * @param blockCountATotal Total amount of blocks stored for the matrix A
   * @param blockSizeBytes size of one block in bytes
   */
  void copyResultFromGPU(int blockCountATotal);

  /**
   * Prints the final runtimes of the complete decomposition
   */
  void printFinalTimes();
};

#endif // CHOLESKYMIXED_HPP
